# === Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ Ğ¸ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ ===
import asyncio
import json
import logging
import random
import requests
import time
from aiogram import Bot, Dispatcher, F, Router
from aiogram.types import Message, CallbackQuery, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.client.default import DefaultBotProperties
from aiogram.methods.send_poll import SendPoll
from aiogram.types.poll_answer import PollAnswer
from aiogram.exceptions import TelegramBadRequest

API_TOKEN = '8055125417:AAEN86Gpsq9BjfpQX2PLbmObZb29tYvehJs'  # Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚Ğµ Ğ½Ğ° ÑĞ²Ğ¾Ğ¹ Ñ‚Ğ¾ĞºĞµĞ½

bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()
dp.include_router(router)

# === Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² ===
# ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸
MAIN_CATEGORIES = {
    "ğŸ›ï¸ Ø§Ù„ØªÙˆØ­ÙŠØ¯": "tawhid",
    "ğŸ“– Ø§Ù„Ø¹Ù„ÙˆÙ… Ø§Ù„Ù‚Ø±Ø¢Ù†": "quran"
}

# ĞŸĞ¾Ğ´ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ Ğ´Ğ»Ñ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ "ĞšĞ¾Ñ€Ğ°Ğ½"
QURAN_SUBCATEGORIES = {
    "Ù¡. Ù…Ù† Ø§Ù„ÙˆØ­ÙŠ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø­ÙƒÙ… ÙˆØ§Ù„Ù…ØªØ´Ø§Ø¨Ù‡": "quran1.json",
    "Ù¢. Ø§Ù„Ø£Ø­Ø±Ù Ø§Ù„Ø³Ø¨Ø¹Ø© ÙˆØ£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ù†Ø²ÙˆÙ„": "quran2.json",
    "Ù£. Ø¬Ù…Ø¹ Ø§Ù„Ù‚Ø±Ø¢Ù† ÙˆØ§Ù„Ù…ÙƒÙŠ ÙˆØ§Ù„Ù…Ø¯Ù†ÙŠ": "quran3.json",
    "Ù¤. Ø£Ù†Ø§Ø³Ø® ÙˆØ§Ù„Ù…Ù†Ø³ÙˆØ®": "quran4.json", 
    "Ù¥. Ø¥Ø¹Ø¬Ø§Ø² Ø§Ù„Ù‚Ø±Ø¢Ù†": "quran5.json",
    "Ù¦. Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø§Øª ÙˆÙ‚ØµØµ ÙˆØªØ±Ø¬Ù…Ø© Ø§Ù„Ù‚Ø±Ø¢Ù†": "quran6.json",
    "Ù§. Ø§Ù„Ù…Ø­ÙƒÙ… ÙˆØ§Ù„Ù…ØªØ´Ø§Ø¨Ù‡": "quran7.json"
}

# ĞŸĞ¾Ğ»Ğ½Ñ‹Ğµ URL-Ğ°Ğ´Ñ€ĞµÑĞ° Ğ´Ğ»Ñ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
BASE_URL = "https://raw.githubusercontent.com/abdullohukr/iu.quizbot/main/"

user_sessions = {}
timer_tasks = {}  # Ğ”Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡ Ñ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğ°Ğ¼Ğ¸

# === Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ ===
class QuizState(StatesGroup):
    in_progress = State()
    selecting_subcategory = State()  # ĞĞ¾Ğ²Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ¾Ğ´ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸

# === ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° /start ===
@router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext):
    kb = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=title)] for title in MAIN_CATEGORIES.keys()
        ],
        resize_keyboard=True
    )
    await message.answer("Ø§Ø®ØªØ± Ø£Ø­Ø¯ Ø§Ù„Ø£Ù‚Ø³Ø§Ù… Ø§Ù„ØªØ§Ù„ÙŠØ©:", reply_markup=kb)
    await state.clear()
    user_id = message.from_user.id
    if user_id in user_sessions:
        del user_sessions[user_id]
    if user_id in timer_tasks and not timer_tasks[user_id].done():
        timer_tasks[user_id].cancel()

# === ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ ===
@router.message(F.text.in_(MAIN_CATEGORIES.keys()))
async def category_select(message: Message, state: FSMContext):
    category = message.text
    category_id = MAIN_CATEGORIES[category]
    
    if category_id == "tawhid":
        # Ğ”Ğ»Ñ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ 'Ø§Ù„ØªÙˆØ­ÙŠØ¯' ÑÑ€Ğ°Ğ·Ñƒ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹
        await load_questions(message, "tawhidquiz.json", state)
    elif category_id == "quran":
        # Ğ”Ğ»Ñ 'ĞšĞ¾Ñ€Ğ°Ğ½Ğ°' Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ´ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸
        kb = ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text=subcategory)] for subcategory in QURAN_SUBCATEGORIES.keys()
            ] + [[KeyboardButton(text="ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]],
            resize_keyboard=True
        )
        await message.answer("Ø§Ø®ØªØ± Ø£Ø­Ø¯ Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹ Ø§Ù„ØªØ§Ù„ÙŠØ©:", reply_markup=kb)
        await state.set_state(QuizState.selecting_subcategory)
        
# === ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ¾Ğ´ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ ĞšĞ¾Ñ€Ğ°Ğ½Ğ° ===
@router.message(QuizState.selecting_subcategory, F.text.in_(QURAN_SUBCATEGORIES.keys()))
async def subcategory_select(message: Message, state: FSMContext):
    subcategory = message.text
    filename = QURAN_SUBCATEGORIES[subcategory]
    await load_questions(message, filename, state)

# === ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ° Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ ===
@router.message(F.text == "ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")
async def back_to_main(message: Message, state: FSMContext):
    await cmd_start(message, state)

# === Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ¸Ğ· Ñ„Ğ°Ğ¹Ğ»Ğ° ===
async def load_questions(message: Message, filename: str, state: FSMContext):
    try:
        url = BASE_URL + filename
        logging.info(f"Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ¸Ğ· {url}")
        
        response = requests.get(url)
        response.raise_for_status()
        
        # Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ³Ğ¾ JSON
        content = response.text
        # ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ¾Ñ‚ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ñ… BOM-Ğ¼Ğ°Ñ€ĞºĞµÑ€Ğ¾Ğ² Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ½ĞµĞ²Ğ¸Ğ´Ğ¸Ğ¼Ñ‹Ñ… ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²
        if content.startswith('\ufeff'):
            content = content[1:]
            
        # Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ñ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
        try:
            # ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ¾Ğ±Ğ½Ğ°Ñ€ÑƒĞ¶Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ğ¸ ĞºĞ¾Ğ½ĞµÑ† Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ° JSON
            start_pos = content.find('[')
            end_pos = content.rfind(']')
            
            if start_pos != -1 and end_pos != -1:
                json_content = content[start_pos:end_pos+1]
                questions = json.loads(json_content)
            else:
                questions = json.loads(content)
                
        except json.JSONDecodeError as e:
            # ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ¸Ğ·Ğ²Ğ»ĞµÑ‡ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½ÑƒÑ Ñ‡Ğ°ÑÑ‚ÑŒ JSON
            logging.warning(f"JSONDecodeError: {e}")
            # Ğ‘Ğ¾Ğ»ĞµĞµ Ğ°Ğ³Ñ€ĞµÑÑĞ¸Ğ²Ğ½Ğ°Ñ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ° JSON
            try:
                # Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµÑ… Ğ½ĞµĞ²Ğ¸Ğ´Ğ¸Ğ¼Ñ‹Ñ… ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ² Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ğ¾Ğ² Ğ² Ğ½Ğ°Ñ‡Ğ°Ğ»Ğµ
                clean_content = content.strip()
                # Ğ£Ğ±ĞµĞ´Ğ¸Ğ¼ÑÑ, Ñ‡Ñ‚Ğ¾ Ñƒ Ğ½Ğ°Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğµ ÑĞºĞ¾Ğ±ĞºĞ¸ Ğ´Ğ»Ñ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ°
                if not clean_content.startswith('['):
                    clean_content = '[' + clean_content
                if not clean_content.endswith(']'):
                    clean_content = clean_content + ']'
                questions = json.loads(clean_content)
            except json.JSONDecodeError:
                # Ğ•ÑĞ»Ğ¸ Ğ²ÑĞµ ĞµÑ‰Ğµ Ğ½Ğµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ñ‹Ğ¹ JSON Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ
                import re
                # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ²ÑĞµ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñ‹ Ğ¼ĞµĞ¶Ğ´Ñƒ Ñ„Ğ¸Ğ³ÑƒÑ€Ğ½Ñ‹Ğ¼Ğ¸ ÑĞºĞ¾Ğ±ĞºĞ°Ğ¼Ğ¸
                objects = re.findall(r'\{[^{}]*\}', content)
                if objects:
                    valid_json = '[' + ','.join(objects) + ']'
                    try:
                        questions = json.loads(valid_json)
                    except:
                        raise Exception("ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ JSON")
                else:
                    raise Exception("ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñ‹ JSON")
        
        if not questions:
            await message.answer("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£Ø³Ø¦Ù„Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹.")
            return

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
        valid_questions = []
        for q in questions:
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ñƒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ° ĞµÑÑ‚ÑŒ Ğ²ÑĞµ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ
            if ('question' in q and 'options' in q and 'correct_option' in q and 
                isinstance(q['options'], list) and len(q['options']) > 0):
                
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¸ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ´Ğ»Ğ¸Ğ½Ñƒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ° (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 300 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²)
                if len(q['question']) > 300:
                    q['question'] = q['question'][:297] + '...'
                
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¸ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ´Ğ»Ğ¸Ğ½Ñƒ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ¾Ğ² Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ° (Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 100 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²)
                valid_options = []
                for opt in q['options']:
                    if isinstance(opt, str):
                        if len(opt) > 100:
                            valid_options.append(opt[:97] + '...')
                        else:
                            valid_options.append(opt)
                
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ¾Ğ² (Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ 2, Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 10)
                if len(valid_options) >= 2 and len(valid_options) <= 10:
                    q['options'] = valid_options
                    
                    # Ğ£Ğ±ĞµĞ´Ğ¸Ğ¼ÑÑ, Ñ‡Ñ‚Ğ¾ correct_option Ğ² Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ğ¾Ğ¼ Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½Ğµ
                    if isinstance(q['correct_option'], int) and 0 <= q['correct_option'] < len(valid_options):
                        valid_questions.append(q)

        if not valid_questions:
            await message.answer("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£Ø³Ø¦Ù„Ø© ØµØ§Ù„Ø­Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹.")
            return

        random.shuffle(valid_questions)
        user_id = message.from_user.id
        user_sessions[user_id] = {
            'questions': valid_questions,
            'current': 0,
            'correct': 0,
            'skipped': 0,
            'answered': set(),
            'start_time': None,
            'chat_id': message.chat.id  # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ chat_id Ğ·Ğ´ĞµÑÑŒ Ğ´Ğ»Ñ Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞ³Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
        }
        await state.set_state(QuizState.in_progress)
        await send_next_question(message, user_id)
        
    except requests.exceptions.RequestException as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞµÑ‚ĞµĞ²Ğ¾Ğ³Ğ¾ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°: {e}")
        await message.answer(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹.")
    except json.JSONDecodeError as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´ĞµĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ JSON: {e}")
        await message.answer(f"Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø³ÙŠÙ‚ Ù…Ù„Ù Ø§Ù„Ø£Ø³Ø¦Ù„Ø©. ÙŠØ±Ø¬Ù‰ Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„.")
    except Exception as e:
        logging.error(f"ĞĞµĞ¿Ñ€ĞµĞ´Ğ²Ğ¸Ğ´ĞµĞ½Ğ½Ğ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e}")
        await message.answer(f"Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹.")

# === ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ° ĞºĞ°Ğº Telegram Ğ²Ğ¸ĞºÑ‚Ğ¾Ñ€Ğ¸Ğ½Ğ° ===
async def send_next_question(message: Message, user_id):
    session = user_sessions.get(user_id)
    if not session:
        return
        
    if session['current'] >= len(session['questions']):
        # Ğ’Ğ¸ĞºÑ‚Ğ¾Ñ€Ğ¸Ğ½Ğ° Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡ĞµĞ½Ğ°
        total_questions = len(session['questions'])
        success_percent = int((session['correct'] / total_questions) * 100) if total_questions > 0 else 0
        
        await message.answer(
            f"âœ… Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø©!\n\n"
            f"ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:\n"
            f"âœ… ØµØ­ÙŠØ­: {session['correct']}\n"
            f"â­ï¸ Ù…ØªØ®Ø·Ø§Ø©: {session['skipped']}\n"
            f"ğŸ“‹ Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total_questions}\n"
            f"ğŸ¯ Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø¬Ø§Ø­: {success_percent}%",
            reply_markup=ReplyKeyboardRemove()
        )
        # ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° ÑĞµÑÑĞ¸Ğ¸
        if user_id in timer_tasks and not timer_tasks[user_id].done():
            timer_tasks[user_id].cancel()
        return

    q = session['questions'][session['current']]
    
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ°Ğ¼Ğ¸ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ Ğ¸ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°
    kb = ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="âŒ Ø¥Ù„ØºØ§Ø¡"), KeyboardButton(text="â¡ï¸ ØªØ®Ø·ÙŠ")]],
        resize_keyboard=True
    )
    
    try:
        poll_message = await bot(SendPoll(
            chat_id=message.chat.id,
            question=q['question'],
            options=q['options'],
            type='quiz',
            correct_option_id=q['correct_option'],
            is_anonymous=False
        ))
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°
        await message.answer("Ø§Ø®ØªØ± Ø¥Ø­Ø¯Ù‰ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª:", reply_markup=kb)
        
        session['current_message_id'] = poll_message.message_id
        session['start_time'] = time.time()
        
        # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ğ¹ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€, ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ
        if user_id in timer_tasks and not timer_tasks[user_id].done():
            timer_tasks[user_id].cancel()
        
        # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€ Ğ´Ğ»Ñ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°
        timer_tasks[user_id] = asyncio.create_task(
            countdown_timer(message, user_id, session['current'])
        )
    except TelegramBadRequest as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Telegram Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°: {e}")
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ğ¼ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ¸ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ
        await message.answer(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„. ÙŠØªÙ… ØªØ®Ø·ÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„.")
        session['skipped'] += 1
        session['current'] += 1
        await send_next_question(message, user_id)
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°: {e}")
        await message.answer(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„. ÙŠØªÙ… ØªØ®Ø·ÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„.")
        session['skipped'] += 1
        session['current'] += 1
        await send_next_question(message, user_id)

# Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğ° Ñ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ñ‹Ğ¼ Ğ¾Ñ‚ÑÑ‡ĞµÑ‚Ğ¾Ğ¼
async def countdown_timer(message, user_id, question_index):
    total_time = 30  # 30 ÑĞµĞºÑƒĞ½Ğ´
    update_interval = 5  # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑÑ‚ÑŒ ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 5 ÑĞµĞºÑƒĞ½Ğ´
    
    try:
        session = user_sessions.get(user_id)
        if not session:
            return
            
        counter_msg = await message.answer(f"â³ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {total_time} Ø«Ø§Ù†ÙŠØ©")
        
        for remaining in range(total_time-update_interval, 0, -update_interval):
            await asyncio.sleep(update_interval)
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑĞµÑÑĞ¸Ñ Ğ²ÑÑ‘ ĞµÑ‰Ñ‘ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ¸ Ğ½Ğµ Ğ±Ñ‹Ğ» Ğ´Ğ°Ğ½ Ğ¾Ñ‚Ğ²ĞµÑ‚
            session = user_sessions.get(user_id)
            if not session or session['current'] != question_index or question_index in session['answered']:
                await bot.delete_message(message.chat.id, counter_msg.message_id)
                return
                
            await bot.edit_message_text(
                f"â³ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {remaining} Ø«Ø§Ù†ÙŠØ©", 
                message.chat.id, 
                counter_msg.message_id
            )
        
        # Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¿Ğ°ÑƒĞ·Ğ°
        await asyncio.sleep(update_interval)
        
        # ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞ´ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ¾Ğ¼
        session = user_sessions.get(user_id)
        if session and session['current'] == question_index and question_index not in session['answered']:
            q = session['questions'][question_index]
            await bot.delete_message(message.chat.id, counter_msg.message_id)
            
            # ĞÑ‚Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ ĞºĞ°Ğº Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¸Ğ·-Ğ·Ğ° Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
            session['skipped'] += 1
            session['answered'].add(question_index)
            
            # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ
            total_questions = len(session['questions'])
            remaining_questions = total_questions - session['current'] - 1
            
            await message.answer(
                f"â° Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª Ù„Ù„Ø³Ø¤Ø§Ù„!\n"
                f"Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: {q['options'][q['correct_option']]}\n\n"
                f"ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø¤Ù‚ØªØ©:\n"
                f"âœ… ØµØ­ÙŠØ­: {session['correct']}\n"
                f"â­ï¸ Ù…ØªØ®Ø·Ø§Ø©: {session['skipped']}\n"
                f"ğŸ“ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: {remaining_questions}\n"
                f"ğŸ“‹ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total_questions}"
            )
            await next_question(message, user_id)
        else:
            await bot.delete_message(message.chat.id, counter_msg.message_id)
    except asyncio.CancelledError:
        # Ğ•ÑĞ»Ğ¸ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½, ÑƒĞ´Ğ°Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸ĞºĞ°
        try:
            await bot.delete_message(message.chat.id, counter_msg.message_id)
        except:
            pass
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğµ: {e}")
        try:
            await bot.delete_message(message.chat.id, counter_msg.message_id)
        except:
            pass

# Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ° Ğº ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¼Ñƒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑƒ
async def next_question(message, user_id):
    session = user_sessions.get(user_id)
    if session:
        # ĞŸĞµÑ€ĞµĞ´ ÑƒĞ²ĞµĞ»Ğ¸Ñ‡ĞµĞ½Ğ¸ĞµĞ¼ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸ĞºĞ° Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑĞµ
        total_questions = len(session['questions'])
        current_progress = session['current'] + 1  # Ñ‚.Ğº. Ğ¸Ğ½Ğ´ĞµĞºÑÑ‹ Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ÑÑ‚ÑÑ Ñ 0
        remaining_questions = total_questions - current_progress
        
        # Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°
        session['current'] += 1
        
        # Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ ĞµÑ‰Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹, Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑ
        if session['current'] < total_questions:
            await message.answer(
                f"ğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: Ø§Ù„Ø³Ø¤Ø§Ù„ {current_progress}/{total_questions}\n"
                f"Ù…ØªØ¨Ù‚ÙŠ: {remaining_questions} Ø£Ø³Ø¦Ù„Ø©"
            )
            
        await send_next_question(message, user_id)

# === ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¾Ğ²-Ğ¿ĞµÑ€ĞµÑ…Ğ²Ğ°Ñ‚ ===
@router.message(QuizState.in_progress, F.text == "âŒ Ø¥Ù„ØºØ§Ø¡")
async def cancel_quiz(message: Message, state: FSMContext):
    user_id = message.from_user.id
    session = user_sessions.get(user_id, {})
    
    # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€
    if user_id in timer_tasks and not timer_tasks[user_id].done():
        timer_tasks[user_id].cancel()
    
    await message.answer(
        f"âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±.\n\nØ§Ù„Ù†ØªØ§Ø¦Ø¬:\nØµØ­ÙŠØ­: {session.get('correct', 0)}\nÙ…ØªØ®Ø·Ø§Ø©: {session.get('skipped', 0)}",
        reply_markup=ReplyKeyboardRemove()
    )
    await state.clear()
    if user_id in user_sessions:
        del user_sessions[user_id]
    
    # ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ /start
    await cmd_start(message, state)

@router.message(QuizState.in_progress, F.text == "â¡ï¸ ØªØ®Ø·ÙŠ")
async def skip_question(message: Message):
    user_id = message.from_user.id
    session = user_sessions.get(user_id)
    if session:
        current_index = session['current']
        if current_index not in session['answered']:
            session['skipped'] += 1
            # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€
            if user_id in timer_tasks and not timer_tasks[user_id].done():
                timer_tasks[user_id].cancel()
            
            # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ½Ğ° Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ
            question = session['questions'][current_index]
            correct_answer = question['options'][question['correct_option']]
            
            await message.answer(
                f"ØªÙ… ØªØ®Ø·ÙŠ Ø§Ù„Ø³Ø¤Ø§Ù„.\n"
                f"Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: {correct_answer}"
            )
            await next_question(message, user_id)

# === ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¾Ğ² Ğ½Ğ° Ğ¾Ğ¿Ñ€Ğ¾Ñ ===
@router.poll_answer()  # ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ…ĞµĞ½Ğ´Ğ»ĞµÑ€ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¾Ğ² Ğ½Ğ° Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹
async def handle_poll_answer(poll_answer: PollAnswer):
    user_id = poll_answer.user.id
    session = user_sessions.get(user_id)
    
    if not session:
        return
        
    current_index = session['current'] - 1
    
    if current_index in session['answered'] or current_index < 0:
        return
        
    session['answered'].add(current_index)
    question = session['questions'][current_index]
    
    # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°
    if user_id in timer_tasks and not timer_tasks[user_id].done():
        timer_tasks[user_id].cancel()
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°
    if poll_answer.option_ids and poll_answer.option_ids[0] == question['correct_option']:
        session['correct'] += 1
        result = "âœ… Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©!"
    else:
        result = f"âŒ Ø®Ø·Ø£. Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: {question['options'][question['correct_option']]}"

    # ĞŸĞ¾Ğ´ÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾ÑÑ‚Ğ°Ğ²ÑˆĞ¸Ñ…ÑÑ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
    total_questions = len(session['questions'])
    answered_questions = len(session['answered'])
    remaining_questions = total_questions - session['current'] - 1

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ñ Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ¶ÑƒÑ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ¹ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¾Ğ¹
    try:
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ¸ Ğ² Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ next_question
        class TempMessage:
            def __init__(self, chat_id):
                self.chat_id = chat_id
                
            async def answer(self, text, reply_markup=None):
                return await bot.send_message(chat_id=self.chat_id, text=text, reply_markup=reply_markup)
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ñ Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ¶ÑƒÑ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ¹ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¾Ğ¹
        await bot.send_message(
            chat_id=session['chat_id'],
            text=f"{result}\n\n"
                f"ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø¤Ù‚ØªØ©:\n"
                f"âœ… ØµØ­ÙŠØ­: {session['correct']}\n"
                f"â­ï¸ Ù…ØªØ®Ø·Ø§Ø©: {session['skipped']}\n"
                f"ğŸ“ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: {remaining_questions}\n"
                f"ğŸ“‹ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total_questions}"
        )
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠĞµĞºÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ² next_question
        temp_message = TempMessage(session['chat_id'])
        
        # ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ¸Ğ¼ Ğº ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¼Ñƒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑƒ
        await next_question(temp_message, user_id)
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°: {e}")
        # ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ Ğ¸ Ğ²ÑĞµ Ñ€Ğ°Ğ²Ğ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¼Ñƒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑƒ
        session['current'] += 1
        
        # ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ
        temp_message = TempMessage(session['chat_id'])
        await send_next_question(temp_message, user_id)

# === Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ±Ğ¾Ñ‚Ğ° ===
async def main():
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    )
    
    # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ±Ğ¾Ğ»ĞµĞµ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ğ¾Ğ³Ğ¾ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº
    logging.getLogger('aiogram').setLevel(logging.INFO)
    
    # Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ±Ğ¾Ñ‚Ğ°
    try:
        await dp.start_polling(bot)
    finally:
        await bot.session.close()

if __name__ == "__main__":
    # Ğ”Ğ»Ñ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Ğ² Ñ„Ğ¾Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ systemd Ğ¸Ğ»Ğ¸ screen/tmux
    asyncio.run(main())